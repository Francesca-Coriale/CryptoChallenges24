from Crypto.Util.number import bytes_to_long, getPrime, inverse, long_to_bytes
from sympy import mod_inverse

c = 90033315892353689857480132288159929767268747529833251467870305173711883154754495217060975875036281454719364603921354588888895712341643646037254066820997554050073817095155772179290159104419599471902201755828407622797360370034692102554941033959932271458299659367048520329890332911161377057122866068202609555967

e = 60016485563460433620911462871489753027091796150597697863772440338904706321535832359517415034149374289955681381097544059467926029963755494161141305994584249448583991034102694954139120453335603006006970009433124857766494518747385902016093339683987307620366742481560543776055295663835860818720290861634213881385
n = 138728501052719695830997827983870257879591108626209095010716818754108501959050430927220695106906763908822395818876460759364322997020222845247478635848425558793671347756842735011885094468024344931360037542098264527076663690119553302046205282212602106990248442514444587909723612295871002063257141634196430659767

# Normal inverse does not work well (I do not retrieve the message)
# d = inverse(e,n)
# print(d)
# m = pow(c,d,n)
# print(long_to_bytes(m).decode())

# uso RSA Wiener ? result = None

#come trovo d : Boneh_durfee.sage
d = 130907063345211827271830776605143751868490159532968572514045305424799065327009793
# To check if d is almost equal to n^0.292
# Convert the integer to scientific notation
scientific_notation = "{:.16e}".format(d)
print(scientific_notation)
print("B: ", pow(n, 0.292))

m = pow(c,d,n)
print(long_to_bytes(m))


